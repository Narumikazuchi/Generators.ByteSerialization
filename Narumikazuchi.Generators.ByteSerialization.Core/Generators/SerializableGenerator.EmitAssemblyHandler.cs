namespace Narumikazuchi.Generators.ByteSerialization.Generators;

public partial class SerializableGenerator
{
    static private void EmitAssemblyHandler(SourceProductionContext context,
                                            Compilation compilation)
    {
        ImmutableArray<IAssemblySymbol> assemblies = compilation.References.Select(compilation.GetAssemblyOrModuleSymbol)
                                                                           .OfType<IAssemblySymbol>()
                                                                           .Where(a => !a.ToDisplayString().StartsWith("System"))
                                                                           .ToImmutableArray();

        INamedTypeSymbol @interface = compilation.GetTypeByMetadataName("Narumikazuchi.Generators.ByteSerialization.IByteSerializer");
        List<INamedTypeSymbol> candidates = new();
        foreach (IAssemblySymbol assembly in assemblies)
        {
            ExploreNamespace(assembly.GlobalNamespace, @interface, candidates);
        }

        StringBuilder interfaces = new();
        if (candidates.Count > 0)
        {
            interfaces.AppendLine(",");
            for (Int32 index = 0;
                 index < candidates.Count;
                 index++)
            {
                interfaces.Append($"    {candidates[index].ToFrameworkString()}");
                if (index < candidates.Count - 1)
                {
                    interfaces.AppendLine(",");
                }
            }
        }

        String source = $@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable
#nullable enable

using System;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;

namespace Narumikazuchi.Generated;

[EditorBrowsable(EditorBrowsableState.Never)]
[CompilerGenerated]
public partial interface __Internal_IAssemblyHandler_{compilation.Assembly.Name.Replace(".", "")} :
    Narumikazuchi.Generators.ByteSerialization.IByteSerializer{interfaces}
{{
    UInt32 Narumikazuchi.Generators.ByteSerialization.IByteSerializer.Variant
    {{
        get
        {{
            return {candidates.Count};
        }}
    }}
}}

[EditorBrowsable(EditorBrowsableState.Never)]
[CompilerGenerated]
public sealed class __Internal_AssemblyHandler_{compilation.Assembly.Name.Replace(".", "")} : __Internal_IAssemblyHandler_{compilation.Assembly.Name.Replace(".", "")}
{{
    static __Internal_AssemblyHandler_{compilation.Assembly.Name.Replace(".", "")}()
    {{
        Type type = typeof(__Internal_AssemblyHandler_{compilation.Assembly.Name.Replace(".", "")});
        foreach (Type @interface in type.GetInterfaces().Where(@interface => @interface.IsGenericType && @interface.GetGenericTypeDefinition() == typeof(Narumikazuchi.Generators.ByteSerialization.ISerializationHandler<>)))
        {{
            _ = Narumikazuchi.Generators.ByteSerialization.TypeCache.GetIdOfType(@interface.GenericTypeArguments[0]);
        }}
    }}
}}";

#if OUTPUT
        System.IO.File.WriteAllText($@"D:\Sources\AssemblyHandler_{compilation.Assembly.Name.Replace(".", "")}.g.cs", source);
#else
        try
        {
            SourceText text = SourceText.From(text: source,
                                              encoding: Encoding.UTF8);
            context.AddSource(hintName: $"AssemblyHandler_{compilation.Assembly.Name.Replace(".", "")}.g.cs",
                              sourceText: text);
        }
        catch { }
#endif
    }

    static private void ExploreNamespace(INamespaceOrTypeSymbol namespaceOrType,
                                         INamedTypeSymbol @interface,
                                         List<INamedTypeSymbol> candidates)
    {
        ImmutableArray<ISymbol> members = namespaceOrType.GetMembers();
        foreach (ISymbol member in members)
        {
            if (member is INamespaceSymbol @namespace)
            {
                ExploreNamespace(@namespace, @interface, candidates);
            }
            else if (member is INamedTypeSymbol type)
            {
                if (!SymbolEqualityComparer.Default.Equals(@interface, type) &&
                    type.BaseType is null &&
                    type.ImplementsInterface(@interface))
                {
                    candidates.Add(type);
                }
            }
        }
    }
}