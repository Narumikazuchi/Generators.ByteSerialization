using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Narumikazuchi.CodeAnalysis;

namespace Narumikazuchi.Generators.ByteSerialization.Generators;

[Generator(LanguageNames.CSharp)]
public sealed partial class SerializableGenerator
{
    static private Boolean IsEligableTypeSyntax(SyntaxNode syntaxNode,
                                                CancellationToken cancellationToken = default)
    {
        return syntaxNode is InvocationExpressionSyntax;
    }

    static private ImmutableArray<ITypeSymbol> TransformToType(GeneratorSyntaxContext context,
                                                               CancellationToken cancellationToken)
    {
        return MethodToTypeReferenceFinder.FindTypes(compilation: context.SemanticModel.Compilation,
                                                     invocation: (InvocationExpressionSyntax)context.Node);
    }

    static private void GenerateSerializationCode(SourceProductionContext context,
                                                  (Compilation, ImmutableArray<ITypeSymbol>) compilationAndTypes)
    {
        (Compilation compilation, ImmutableArray<ITypeSymbol> types) = compilationAndTypes;
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        types = types.Where(type => !type.IsInterface())
                     .Where(type => type.SpecialType is not SpecialType.System_IntPtr
                                                     and not SpecialType.System_UIntPtr
                                                     and not SpecialType.System_Delegate
                                                     and not SpecialType.System_MulticastDelegate)
                     .Distinct((IEqualityComparer<ITypeSymbol>)SymbolEqualityComparer.Default)
                     .ToImmutableArray();

        CodeAnalysis.Extensions.ClearCaches();
        Extensions.ClearCaches();

        AssemblyHandlerEmitter.Emit(types: types,
                                    context: context,
                                    compilation: compilation);

        Int32 index = 0;
        foreach (ITypeSymbol type in types)
        {
            StringBuilder builder = new();
            builder.AppendLine("//------------------------------------------------------------------------------");
            builder.AppendLine("// <auto-generated>");
            builder.AppendLine("//     This code was generated by a tool.");
            builder.AppendLine("//");
            builder.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            builder.AppendLine("//     the code is regenerated.");
            builder.AppendLine("// </auto-generated>");
            builder.AppendLine("//------------------------------------------------------------------------------");
            builder.AppendLine("#pragma warning disable");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Reflection;");
            builder.AppendLine("using System.Reflection.Emit;");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine("using System.Runtime.InteropServices;");
            builder.AppendLine("using System.Threading;");
            builder.AppendLine();
            builder.AppendLine("namespace Narumikazuchi.Generated.Internals.ByteSerialization;");
            builder.AppendLine();
            builder.AppendLine($"public unsafe partial interface IAssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()} : {GlobalNames.ISerializationHandler(type)}");
            builder.AppendLine("{");
            builder.AppendLine("    [CompilerGenerated]");
            builder.AppendLine($"    Int32 {GlobalNames.ISerializationHandler(type)}.Deserialize(Byte* buffer, out {type.ToFrameworkString()} result)");
            builder.AppendLine("    {");
            builder.AppendLine($"        return __{index}.Deserialize(buffer, out result);");
            builder.AppendLine("    }");
            builder.AppendLine();
            builder.AppendLine("    [CompilerGenerated]");
            builder.AppendLine($"    Int32 {GlobalNames.ISerializationHandler(type)}.GetExpectedArraySize({type.ToFrameworkString()} value)");
            builder.AppendLine("    {");
            builder.AppendLine($"        return __{index}.GetExpectedArraySize(value);");
            builder.AppendLine("    }");
            builder.AppendLine();
            builder.AppendLine("    [CompilerGenerated]");
            builder.AppendLine($"    Int32 {GlobalNames.ISerializationHandler(type)}.Serialize(Byte* buffer, {type.ToFrameworkString()} value)");
            builder.AppendLine("    {");
            builder.AppendLine($"        return __{index}.Serialize(buffer, value);");
            builder.AppendLine("    }");
            builder.AppendLine();
            builder.AppendLine("    [CompilerGenerated]");
            builder.AppendLine($"    {GlobalNames.NAMESPACE}.TypeIdentifier {GlobalNames.ISerializationHandler(type)}.TypeIdentifier");
            builder.AppendLine("    {");
            builder.AppendLine("        get");
            builder.AppendLine("        {");
            builder.AppendLine($"            return __{index}.Identifier;");
            builder.AppendLine("        }");
            builder.AppendLine("    }");
            builder.AppendLine();
            builder.AppendLine("    [CompilerGenerated]");
            builder.AppendLine($"    static private class __{index}");
            builder.AppendLine("    {");

            if (type is INamedTypeSymbol named)
            {
                ImmutableArray<ISymbol> members = named.GetMembersToSerialize();
                DeserializeCodeWriter.WriteMethod(type: named,
                                                  members: members,
                                                  builder: builder);
                builder.AppendLine();

                SizeCodeWriter.WriteMethod(type: named,
                                           members: members,
                                           builder: builder);
                builder.AppendLine();

                SerializeCodeWriter.WriteMethod(type: named,
                                                members: members,
                                                builder: builder);
                builder.AppendLine();
                index++;
            }
            else if (type is IArrayTypeSymbol array)
            {
                DeserializeCodeWriter.WriteMethod(array: array,
                                                  builder: builder);
                builder.AppendLine();

                SizeCodeWriter.WriteMethod(array: array,
                                           builder: builder);
                builder.AppendLine();

                SerializeCodeWriter.WriteMethod(array: array,
                                                builder: builder);
                builder.AppendLine();
                index++;
            }

            builder.AppendLine("        [CompilerGenerated]");
            builder.AppendLine($"        static public {GlobalNames.NAMESPACE}.TypeIdentifier Identifier {{ get; }} = new {GlobalNames.NAMESPACE}.TypeIdentifier(typeof({type.ToFrameworkString()}));");

            if (type is INamedTypeSymbol named2 &&
                !named2.HasDefaultConstructor() &&
                !named2.IsRecord)
            {
                static String MemberToParameter(ISymbol member)
                {
                    if (member is IFieldSymbol field)
                    {
                        return $"{field.Type.ToFrameworkString()} {field.Name}";
                    }
                    else if (member is IPropertySymbol property)
                    {
                        return $"{property.Type.ToFrameworkString()} {property.Name}";
                    }
                    else
                    {
                        return String.Empty;
                    }
                }

                builder.AppendLine();

                ImmutableArray<ISymbol> members = named2.GetMembersToSerialize();
                ConstructorCodeWriter.WriteMethod(type: named2,
                                                  members: members,
                                                  builder: builder);

                builder.AppendLine();
                builder.AppendLine($"        static private readonly Lazy<Constructor> s_Constructor = new Lazy<Constructor>(GenerateConstructor, LazyThreadSafetyMode.ExecutionAndPublication);");

                String parameters = String.Join(", ", members.Select(MemberToParameter));

                builder.AppendLine();
                builder.AppendLine($"        private delegate {named2.ToFrameworkString()} Constructor({parameters});");
            }

            builder.AppendLine("    }");

            builder.Append('}');

            String source = builder.ToString();
#if OUTPUT
            System.IO.File.WriteAllText($@"D:\Sources\Narumikazuchi.Generated.Internals.ByteSerialization.Handler.{type.ToFileString()}.g.cs", source);
#else
        try
        {
            SourceText text = SourceText.From(text: source,
                                              encoding: Encoding.UTF8);
            context.AddSource(hintName: $"Narumikazuchi.Generated.Internals.ByteSerialization.Handler.{type.ToFileString()}.g.cs",
                              sourceText: text);
        }
        catch { }
#endif
        }
    }
}