using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Narumikazuchi.CodeAnalysis;

namespace Narumikazuchi.Generators.ByteSerialization.Generators;

[Generator(LanguageNames.CSharp)]
public sealed partial class SerializableGenerator
{
    static private Boolean IsEligableTypeSyntax(SyntaxNode syntaxNode,
                                                CancellationToken cancellationToken = default)
    {
        return syntaxNode is InvocationExpressionSyntax;
    }

    static private ITypeSymbol TransformToType(GeneratorSyntaxContext context,
                                               CancellationToken cancellationToken)
    {
        return MethodToTypeReferenceFinder.FilterType(compilation: context.SemanticModel.Compilation,
                                                     invocation: (InvocationExpressionSyntax)context.Node);
    }

    private void GenerateSerializationCode(SourceProductionContext context,
                                           (Compilation, ImmutableArray<ITypeSymbol>) compilationAndTypes)
    {
        m_Logger.LogInformation($"Beginning new generation cycle for assembly '{compilationAndTypes.Item1.Assembly.MetadataName}'");
        CodeAnalysis.Extensions.ClearCaches();
        Extensions.ClearCaches();

        (Compilation compilation, ImmutableArray<ITypeSymbol> types) = compilationAndTypes;
        if (types.IsDefaultOrEmpty)
        {
            m_Logger.LogInformation("No types eligable for code generation found.");
            return;
        }

        ImmutableArray<IAssemblySymbol> assemblies = compilation.References.Select(compilation.GetAssemblyOrModuleSymbol)
                                                                           .OfType<IAssemblySymbol>()
                                                                           .Concat(new IAssemblySymbol[] { compilation.Assembly })
                                                                           .ToImmutableArray();

        ImmutableDictionary<ITypeSymbol, ImmutableHashSet<INamedTypeSymbol>> customSerializers = CustomHandlerFinder.FindTypesWithCustomHandlerIn(compilation);

        types = types.Where(type => type.CanBeSerialized(assemblies, customSerializers))
                     .Where(type => !type.IsUnmanagedSerializable())
                     .Distinct<ITypeSymbol>(SymbolEqualityComparer.Default)
                     .ToImmutableArray();

        m_Logger.LogInformation("Now emitting base assembly handler...");
        AssemblyHandlerEmitter.Emit(context: context,
                                    compilation: compilation);
        m_Logger.LogInformation("Finished emitting base assembly handler.");

        Int32 index = 0;
        foreach (ITypeSymbol type in types)
        {
            m_Logger.LogInformation($"Now emitting assembly handler for type '{type.ToFrameworkString()}'...");

            StringBuilder builder = new();
            builder.AppendLine("//------------------------------------------------------------------------------");
            builder.AppendLine("// <auto-generated>");
            builder.AppendLine("//     This code was generated by a tool.");
            builder.AppendLine("//");
            builder.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            builder.AppendLine("//     the code is regenerated.");
            builder.AppendLine("// </auto-generated>");
            builder.AppendLine("//------------------------------------------------------------------------------");
            builder.AppendLine("#pragma warning disable");
            builder.AppendLine("#nullable disable");
            builder.AppendLine();
            builder.AppendLine("namespace Narumikazuchi.Generated.Internals.ByteSerialization;");
            builder.AppendLine();
            builder.AppendLine($"public partial interface IAssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()} : {GlobalNames.ISerializationHandler(type)}");
            builder.AppendLine("{");

            DeserializeCodeWriter deserializeCodeWriter = new(assemblies: assemblies,
                                                              customSerializers: customSerializers,
                                                              logger: m_Logger);
            builder.AppendLine(deserializeCodeWriter.WriteMethod(type));

            SizeCodeWriter sizeCodeWriter = new(assemblies: assemblies,
                                                customSerializers: customSerializers,
                                                logger: m_Logger);
            builder.AppendLine(sizeCodeWriter.WriteMethod(type));

            SerializeCodeWriter serializeCodeWriter = new(assemblies: assemblies,
                                                          customSerializers: customSerializers,
                                                          logger: m_Logger);
            builder.Append(serializeCodeWriter.WriteMethod(type));

            index++;

            builder.Append('}');

            String source = builder.ToString();
#if DEBUG && OUTPUT
            Directory.CreateDirectory(Path.Combine(Environment.CurrentDirectory, @"..\Generated"));
            File.WriteAllText(Path.Combine(Environment.CurrentDirectory, $@"..\Generated\Narumikazuchi.Generated.Internals.ByteSerialization.Handler.{type.ToFileString()}.g.cs"), source);
#endif
            try
            {
                SourceText text = SourceText.From(text: source,
                                                  encoding: Encoding.UTF8);
                context.AddSource(hintName: $"Narumikazuchi.Generated.Internals.ByteSerialization.Handler.{type.ToFileString()}.g.cs",
                                  sourceText: text);
            }
            catch (Exception exception)
            {
                m_Logger.LogError($"Error during emitting of assembly handler for type '{type.ToFrameworkString()}':");
                m_Logger.LogError(exception.ToString());
            }

            m_Logger.LogInformation($"Finished emitting assembly handler for type '{type.ToFrameworkString()}'.");
        }
    }

    private void ConfigureLogging(SourceProductionContext context,
                                  ImmutableArray<AdditionalText> texts)
    {
        foreach (AdditionalText text in texts)
        {
            SourceText source = text.GetText();
            foreach (TextLine line in source.Lines)
            {
                String contents = line.ToString();
                String[] key_value_pair = contents.Split('=');
                if (key_value_pair.Length != 2)
                {
                    continue;
                }

                String key = key_value_pair[0].Trim();
                if (key is "byte_serialization_log_path")
                {
                    m_Logger.LogPath = key_value_pair[1].Trim();
                }
                else if (key is "byte_serialization_loggin_enabled")
                {
                    if (Boolean.TryParse(key_value_pair[1].Trim(), out Boolean enabled))
                    {
                        m_Logger.LoggingEnabled = enabled;
                    }
                }
            }
        }
    }

    private readonly Logger m_Logger = new();
}