using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Narumikazuchi.CodeAnalysis;

namespace Narumikazuchi.Generators.ByteSerialization.Generators;

[Generator(LanguageNames.CSharp)]
public sealed partial class SerializableGenerator
{
    static private Boolean IsEligableTypeSyntax(SyntaxNode syntaxNode,
                                                CancellationToken cancellationToken = default)
    {
        return syntaxNode is InvocationExpressionSyntax;
    }

    static private ITypeSymbol TransformToType(GeneratorSyntaxContext context,
                                               CancellationToken cancellationToken)
    {
        return MethodToTypeReferenceFinder.FilterType(compilation: context.SemanticModel.Compilation,
                                                     invocation: (InvocationExpressionSyntax)context.Node);
    }

    static private void GenerateSerializationCode(SourceProductionContext context,
                                                  (Compilation, ImmutableArray<ITypeSymbol>) compilationAndTypes)
    {
        CodeAnalysis.Extensions.ClearCaches();
        Extensions.ClearCaches();

        (Compilation compilation, ImmutableArray<ITypeSymbol> types) = compilationAndTypes;
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        ImmutableDictionary<ITypeSymbol, ImmutableHashSet<INamedTypeSymbol>> customSerializers = CustomHandlerFinder.FindTypesWithCustomHandlerIn(compilation);

        types = types.Where(type => type.CanBeSerialized(customSerializers))
                     .Where(type => !type.IsUnmanagedSerializable())
                     .Distinct<ITypeSymbol>(SymbolEqualityComparer.Default)
                     .ToImmutableArray();

        AssemblyHandlerEmitter.Emit(context: context,
                                    compilation: compilation);

        Int32 index = 0;
        foreach (ITypeSymbol type in types)
        {
            StringBuilder builder = new();
            builder.AppendLine("//------------------------------------------------------------------------------");
            builder.AppendLine("// <auto-generated>");
            builder.AppendLine("//     This code was generated by a tool.");
            builder.AppendLine("//");
            builder.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            builder.AppendLine("//     the code is regenerated.");
            builder.AppendLine("// </auto-generated>");
            builder.AppendLine("//------------------------------------------------------------------------------");
            builder.AppendLine("#pragma warning disable");
            builder.AppendLine("#nullable disable");
            builder.AppendLine();
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Reflection;");
            builder.AppendLine("using System.Reflection.Emit;");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine("using System.Runtime.InteropServices;");
            builder.AppendLine("using System.Threading;");
            builder.AppendLine();
            builder.AppendLine("namespace Narumikazuchi.Generated.Internals.ByteSerialization;");
            builder.AppendLine();
            builder.AppendLine($"public partial interface IAssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()} : {GlobalNames.ISerializationHandler(type)}");
            builder.AppendLine("{");

            DeserializeCodeWriter deserializeCodeWriter = new(customSerializers);
            builder.AppendLine(deserializeCodeWriter.WriteMethod(type));

            SizeCodeWriter sizeCodeWriter = new(customSerializers);
            builder.AppendLine(sizeCodeWriter.WriteMethod(type));

            SerializeCodeWriter serializeCodeWriter = new(customSerializers);
            builder.Append(serializeCodeWriter.WriteMethod(type));

            index++;

            builder.Append('}');

            String source = builder.ToString();
#if DEBUG && OUTPUT
            Directory.CreateDirectory(Path.Combine(Environment.CurrentDirectory, @"..\Generated"));
            File.WriteAllText(Path.Combine(Environment.CurrentDirectory, $@"..\Generated\Narumikazuchi.Generated.Internals.ByteSerialization.Handler.{type.ToFileString()}.g.cs"), source);
#endif
            try
            {
                SourceText text = SourceText.From(text: source,
                                                  encoding: Encoding.UTF8);
                context.AddSource(hintName: $"Narumikazuchi.Generated.Internals.ByteSerialization.Handler.{type.ToFileString()}.g.cs",
                                  sourceText: text);
            }
            catch { }
        }
    }
}