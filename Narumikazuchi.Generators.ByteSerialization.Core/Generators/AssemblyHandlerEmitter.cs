using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Narumikazuchi.CodeAnalysis;

namespace Narumikazuchi.Generators.ByteSerialization.Generators;

static public class AssemblyHandlerEmitter
{
    static public void Emit(ImmutableArray<ITypeSymbol> types,
                            SourceProductionContext context,
                            Compilation compilation)
    {
        ImmutableArray<IAssemblySymbol> assemblies = compilation.References.Select(compilation.GetAssemblyOrModuleSymbol)
                                                                           .OfType<IAssemblySymbol>()
                                                                           .Where(a => !a.ToDisplayString().StartsWith("System"))
                                                                           .ToImmutableArray();

        List<INamedTypeSymbol> candidates = new();
        INamedTypeSymbol byteSerializer = compilation.GetTypeByMetadataName(GlobalNames.IBYTESERIALIZER);
        foreach (IAssemblySymbol reference in assemblies)
        {
            ExploreNamespace(namespaceOrType: reference.GlobalNamespace,
                             byteSerializer: byteSerializer,
                             candidates: candidates);
        }

        StringBuilder interfaces = new();
        if (candidates.Count > 0)
        {
            interfaces.AppendLine(",");
            for (Int32 index = 0;
                 index < candidates.Count;
                 index++)
            {
                interfaces.Append($"    {candidates[index].ToFrameworkString()}");
                if (index < candidates.Count - 1)
                {
                    interfaces.AppendLine(",");
                }
            }
        }

        String source = $@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable
#nullable enable

using System;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;

namespace Narumikazuchi.Generated.Internals.ByteSerialization;

[EditorBrowsable(EditorBrowsableState.Never)]
[CompilerGenerated]
public partial interface IAssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()} :
    {GlobalNames.IBYTESERIALIZER}{interfaces}
{{
    UInt32 {GlobalNames.IBYTESERIALIZER}.Variant
    {{
        get
        {{
            return {candidates.Count};
        }}
    }}
}}

[EditorBrowsable(EditorBrowsableState.Never)]
[CompilerGenerated]
public sealed class AssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()} : IAssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()}
{{
    public AssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()}()
    {{ }}
}}";

#if OUTPUT
        System.IO.File.WriteAllText($@"D:\Sources\Narumikazuchi.Generated.Internals.ByteSerialization.AssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()}.g.cs", source);
#else
        try
        {
            SourceText text = SourceText.From(text: source,
                                              encoding: Encoding.UTF8);
            context.AddSource(hintName: $"Narumikazuchi.Generated.Internals.ByteSerialization.AssemblyHandler_{compilation.Assembly.Name.ToValidCSharpTypename()}.g.cs",
                              sourceText: text);
        }
        catch { }
#endif
    }

    static private void ExploreNamespace(INamespaceOrTypeSymbol namespaceOrType,
                                         INamedTypeSymbol byteSerializer,
                                         List<INamedTypeSymbol> candidates)
    {
        ImmutableArray<ISymbol> members = namespaceOrType.GetMembers();
        foreach (ISymbol member in members)
        {
            if (member is INamespaceSymbol @namespace)
            {
                ExploreNamespace(namespaceOrType: @namespace,
                                 byteSerializer: byteSerializer,
                                 candidates: candidates);
            }
            else if (member is INamedTypeSymbol type)
            {
                if (!SymbolEqualityComparer.Default.Equals(byteSerializer, type) &&
                    type.BaseType is null &&
                    type.ImplementsInterface(byteSerializer))
                {
                    candidates.Add(type);
                }
            }
        }
    }
}